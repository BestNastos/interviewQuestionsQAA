# Testing Basics Q&A 

### 1. Что такое Quality Assurance (обеспечение качества)?
Quality Assurance (обеспечение качества) - 
это превентивный процесс, задачей которого является обеспечение качества продукта в 
будущем. Сюда входит эффективный менеджмент, оборудование.

### 2. Что такое Quality Control (контроль качества)?
Quality Control (контроль качества) - выяснение, готов ли конкретный продукт к выпуску, 
соответствует ли требованиям, соответствует ли уровню качества. QC ориентирован на проверку продукта, включает в себя многие процессы, такие как анализ кода, технические обзоры, анализ дизайна, тестирование и пр.
Quality Assurance включает Quality Control, а тот включает тестирование.

### 3. Что такое тестирование?
Тестирование -  это способ оценить качество ПО и сократить риск возникновения 
программных ошибок во время его использования (ISTQB).

### 4. Какие виды тестирования вы знаете?
Существует много классификаций видов тестирования.
Далее виды классификаций из "Тестирование дот ком" Савина с моими небольшими пометками:

Виды классификаций:

**1. По объекту тестирования:**
- _функциональное тестирование_ (functional testing);
- _тестирование интерфейса пользователя_ (UI testing);
- _тестирование локализации_ (localization testing);
- _тестирование скорости и надежности_ (load/stress/performance testing);
- _тестирование безопасности_ (security testing);
- _тестирование опыта пользователя_ (usability testing);
- _тестирование совместимости_ (compatibility testing).

Подробнее о классификации по объекту тестирования будет ниже.

**2. По времени проведения тестирования:**
- до передачи пользователю - альфа-тестирование (alphatesting);
    - _тест приемки_ (smoke test, sanity test или confidence test) - проверяются основные
      функциональности (напр., возможность залогиниться);
    - _тестирование новых функциональностей_ (new feature
      testing) - если тест приемки пройден, то дальше тестирование новых фич;
    - _регрессивное тестирование_ (regression testing)  - проверка по старым тест кейсам;
    - _тест сдачи_ (acceptance or certification test) - 
      финальное тестирование на соответствие критериям приемки,
      в т.ч. тесты по пофикшенным багам,
      проверка не сломалось ли чего после фиксов;
- после передачи пользователю — бета-тестирование (beta
  testing).

**3. По степени изолированности тестируемых компонентов:**

Данная классификация видов тестирования так же известна как
классификация по **уровням** тестирования.

Итак, **уровни тестирования**:
- _компонентное_ тестирование (component testing) - юнит тесты;
- _интеграционное_ тестирование (integration testing) - 
  тестирование взаимодействия двух и более компонентов. Например, в 
  интернет-магазине: клик на "поместить в корзину" и переход в
  корзину, проверка, что товар там. Иногда интеграционный тест - 
  он же и e2e тест;
- _системное (или энд-ту-энд)_ тестирование 
  (system or end to-end / е2е) - покрытие конкретного use-кейса
  начиная от логина до окончания самого действия, через UI, 
  как это бы сделал пользователь (например, если это интернет-магазин:
  начиная от залогинивания и до подтверждения заказа).

**4. По знанию внутренностей системы:**
- _черный ящик_ (black box testing) - поведенческое тестирование. 
   Основано на паттернах поведения пользователя без знания бэкэнда.
- _серый ящик_ (grey box testing) - тестирование с частичным знанием о том, 
   как работает система изнутри.
- _белый ящик_ (white box testing) - основано на знаниях о логике бэкэнда и о слабых местах. 
  Юнит тесты - часть white box тестирования.
  
**5. По СУбъекту тестирования:**
- _альфа-тестирование_ - тестирование сотрудником компании, разрабатывающей ПО.
- _бета-тестирование_ - тестирование человеком, не являющимся сотрудником компании,
  разрабатывающей продукт. Обычно это юзабилити тестирование (когда ютуб выкатывает 
  новую фичу только на часть существующих аккаунтов, это своего рода бета тестирование,
  за исключением того факта что бета тестирование - дело добровольное).
  
**6. По критерию "позитивности" сценариев:**
- _позитивное тестирование_ (positive testing) - когда ожидаемый результат тест кейса -
  успешное выполнение действия и отсутствие ошибок. 
  Эти тесты выполняются перед негативным тестированием, т.к. нужно знать что система 
  вообще рабочая, прежде чем приступать к негативному тестированию.
- _негативное тестирование_ (negative testing). Когда ожидаемый результат тест кейса - ошибка 
  (например, при неправильно введенном пароле)
  
**7. По степени автоматизированности тестирования:**

- _ручное_ тестирование (manual testing);
- _автоматизированное_ тестирование (automated testing); 
- _смешанное_/полуавтоматизированное тестирование (semiautomated testing) -
  с использованием инструментов.
  
**8. По степени подготовки к тестированию:**

- _тестирование по документации_ (formal/documented testing);
- _эд хок-тестирование_ (ad hoc testing) - без планирования и документации.

### 5. Что такое функциональность и функциональное тестирование?
Функциональное тестирование -  это тестирование ПО в целях проверки реализуемости 
функциональных требований, то есть способности ПО в определённых условиях решать задачи, 
нужные пользователям. Функциональность — это то, что делает продукт полезным для пользователя.
Функциональные требования определяют, что именно делает ПО, 
какие задачи оно решает.

### 6. Какие виды нефункционального тестирования вы знаете?

1. _**Тестирование производительности**_ (подробнее ниже).
2. _**Тестирование GUI**_ - тестирование пользовательского интерфейса, 
   проверка верного отображения элементов. Обычно тестирование интерфейса покрывается 
   при функциональном тестировании (функциональные UI-тесты)
3. _**Тестирование Usability**_ - тестирование удобства и понятности. Этот вид тестов не поддается 
   автоматизации, т.к. оценка его результатов субъективна.
4. _**Тестирование безопасности**_ - оценка уязвимости программного обеспечения к различным атакам. 
   (напр., убедиться что сайт/аккаунт не будет взломан).
5. _**Тестирование локализации**_ - проверка адаптации под определенную страну: 
   проверка верности перевода текста на целевые языки, а так же
   корректного его отображения (напр., проверка того, что перевод помещается в поля/формы).
6. _**Тестирование совместимости**_ - проверка работы ПО в разных браузерах, 
   на разных устройствах и ОС.

### 7. Какие виды тестирования производительности вы знаете?
_**Тестирование производительности**_ - позволяет определить как себя ведет приложение 
при разном наплыве пользователей и разном объеме данных.

_**Виды тестирования производительности**_:
1. _**Нагрузочное тестирование** (нормальная нагрузка)_ - 
   проверка работоспособности приложения при наплыве ожидаемого количества 
   пользователей в течении ~30 минут.
2. _**Тестирование масштабируемости (Scalability)** (нагрузка больше нормы)_ - 
   наблюдение за производительностью при нагрузке чуть больше ожидаемого.
3. _**Тестирование стабильности или надежности** (средняя нагрузка или меньше нормы)_ - 
   проверка работоспособности приложения при длительном тестировании со средним 
   уровнем нагрузки.
4. _**Стрессовое тестирование** (максимальная нагрузка) -_ 
   позволяет проверить насколько приложение работоспособно в условиях стресса и также 
   оценить способность к регенерации, т.е. к возвращению к нормальному состоянию после 
   прекращения воздействия стресса.

### 8. Что такое тестовый фреймворк?

Тестовый фреймворк - это основа, на которой держится вся 
техническая часть проекта по автоматизации тестирования. 
Это совокупность библиотек, подходов и практик для организации 
тестирования. Это система, которая устанавливает правила автоматизации, обеспечивает 
основу автоматизации тестирования и упрощает автоматизацию. В первую очередь фреймворк 
решает вопросы проектирования. TIP: Составляя фреймворк с нуля, лучше потратить хотя бы 
несколько дней, рисуя блок-схемы на листочке, и лишь затем приступать к реализации.

### 9. Какие тесты стоит автоматизировать, а какие нет?

Стоит автоматизировать:
- Тесты, критические для бизнеса (High Risk, Smoke);
- Тесты, которые необходимо выполнять часто;
- Тесты, представляющие сложность для мануального выполнения;
  (например, тест со сложными предусловиями, в которых легко допустить 
  ошибку в силу человеческого фактора);
- Тест-кейсы, на мануальное выполнение которых уходит много времени.

Не стоит автоматизировать:
- Тесты, которые часто подвергаются изменениям;
  в силу меняющихся требований;
- Тесты, которые имеют тенденцию к нестабильности
  (например, в некоторых случаях это могут быть UI-тесты на drag&drop);
- Эксплоратори / ad hoc тесты - они проводятся не по расписанным шагам, 
  а на основе опыта мануального тестировщика. Соответственно,
  каждое проведение эксплоратори теста будет по-своему уникальным;
- Юзабилити тесты - т.к. оценка приложения на удобство субъективна;
- Если прогонка теста требуется очень редко, например, раз в год;
- Если прогон теста занимает больше времени, 
  чем его мануальное выполнение
  (но с хорошо написанным автотестом такого, скорее всего, не будет)
- Тесты, автоматизация которых не оправдывает затрату ресурсов -
тесты с низким ROI (return of investment). Например, 
  если сам проект - всего на несколько месяцев, то автоматизация, 
  скорее всего, не окупится. 
  
### Что вы знаете о ROI в автоматизации и как ее рассчитать?

ROI (return of investment) - окупаемость инвестиций.
        
    ROI = Savings ÷ Investment.

Экономия (Savings): экономия ресурсов при замене мануальных тестов 
на автотесты.

Инвестиции (Investment): суммарные затраты на автоматизацию.

    Экономия = (время на выполнение 1 мануального теста - 
    время на прогон 1 автотеста) * количество тестов * количество прогонов

    Инвестиция = время на построение фреймворка + 
    (время на написание 1 автотеста * количество тестов) + стоимость поддержки

Расчет стоимости поддержки автотестов строится на скорости 
исправления падающего теста и количества ежедневно падающих тестов.

### В каком порядке вы будете автоматизировать тесты (по приоритету)?

- Тесты, критические для бизнеса (High Risk, Smoke);
- Сначала наиболее распространенные use-кейсы, 
  потом - менее распространенные;
- Сначала позитивные сценарии, потом негативные;
- Сначала АПИ тесты (CRUD), потом UI, т.к. в первую очередь важно,
чтобы не было ошибок в логике приложения и чтобы сама функциональность
  работала нормально;
- При определении приоритета автоматизации UI-тестов принимать во 
внимание, какие тесты покрывают тестирование функциональности, а
  какие - исключительно тестируют GUI. Например, проверка цвета 
  определенного элемента на странице не так важна, как проверка 
  функциональности.

### Опишите идеальный тест-кейс
1. Независимый от других тест-кейсов
2. Имеет краткое, емкое и понятное название
3. Предоставляет все необходимые предусловия и данные
4. Четко формулирует шаги: этот тест кейс должен мочь пройти без вопросов даже новичок, незнакомый с системой
5. Недвусмысленно описывает ожидаемый результат

### Опишите идеальный баг репорт
Ответ схож с предыдущим.
1. Один баг-репорт должен описывать только один дефект
2. Имеет краткое, емкое и понятное название
3. Предоставляет все необходимые предусловия и данные
4. Четко формулирует шаги: этот баг должен мочь воспроизвести без вопросов даже новичок, 
   незнакомый с системой
5. Недвусмысленно описывает ожидаемый результат и его отличие от фактического результата.
6. Имеет в приложении скриншот или, при необходимости, видео.
7. Не дублирует существующие баг репорты.

### Каков жизненный цикл бага?
- open
- in progress
- resolved / ready for test
- closed
- reopen (при повторном обнаружении)
- blocked (при наличии проблем (напр. других багов), препятствующих исправлению этого бага)

### В чем отличие Severity бага от его Priority?
_Серьезность бага (Severity)_ - 
это атрибут, характеризующий влияние дефекта на работоспособность приложения.

_Приоритет бага (Priority)_ - 
это атрибут, указывающий на очередность выполнения задачи или устранения дефекта.

_Пример_: перевернутое вверх ногами изображение логотипа компании на ее сайте имеет низкое 
значение Severity, т.к. не влияет на работоспособность приложения. Но, скорее всего, 
будет иметь высокий приоритет, т.к. эту проблему, вероятно, захотят исправить как можно скорее.

### Что необходимо сделать перед заведением баг-репорта? 
- проверить воспроизводимость бага руками (если баг пойман автотестом, т.к. автотест может 
  упасть не только по причине поимки бага, но и из-за проблем с окружением, например)
- проверить воспроизводимость на разных окружениях 
  (напр., в разных браузерах или на разных версиях приложения),
- проверить, не был ли данный баг уже заведен кем-то другим (избегаем дубликатов)


### Назовите основные этапы тестирования
1. Подготовка к тестированию:
   - знакомство с документацией, 
   - знакомство с продуктом,
   - планирование, определение видов тестирования для этого продукта.
2. Тестирование (сначала проверка новых функциональностей, потом регрессивноее тест-е)
3. Обработка результатов и составление отчетов

### В чем разница между статическим и динамическим тестированием?
Статическое тестирование это проверка ПО без его запуска, например, вычитка кода. 
Динамическое тестирование - это проверка ПО в действии.

### В чем разница между тест стратегией и тест планом?
Когда дело касается тестирования, тест план отвечает на вопрос "как". То есть, "Как будет
выполняться тест стратегия?". В то время как тест стратегия отвечает за аспекты, отвечающие
на вопрос "что". Она включает ответы на такие вопросы как: 
"Что является целью процесса тестирования?",
"Что из себя представляет скоуп тестирования?" и т.д.

_К примеру, тестовая стратегия может определять:_
- инструменты
- тестируем ли веб или моб
- на каких браузерах тестируем
- риски
- виды тестирования (функциональное, нефункциональное)
- скоуп тестирования фичи
- что идет на мануальное тестирование, что на автомейшен и что на эксплоратори
- техники тестирования

(TBD)

### Какие техники тест-дизайна вы знаете?
_**Эквивалентное разбиение**_: делим входные значения на группы и принимаем за аксиому, 
что для всех значений в данной группе результат будет аналогичным.
Например, интернет-магазин дает разные скидки посетителям в зависимости от возрастной группы.
Можем создать по 1 кейсу для каждой возрастной группы, чтобы не создавать кейсы для 
каждого возраста.

_**Техника граничных значений**_ основана на предположении, что большинство ошибок может возникнуть 
на границах эквивалентных классов. Она тесно связана с вышеописанной 
техникой эквивалентного разбиения, из-за чего часто используется с ней 
в паре. Например, если поле принимает значения от 5 до 10, то мы можем подать в тест
граничные значения: 5 и 4, 10 и 9.

_**Таблица принятия решений**_ - техника, помогающая наглядно изобразить комбинаторику 
условий из ТЗ. Например: у нас форма регистрации, поля которой надо заполнить 
несколькими валидными значениями для успешной регистрации. Таблица будет состоять 
из всевозможных комбинаций значений полей и результатом для каждой из комбинаций:

- валидный емейл + валидное имя + невалидный пароль = отказ в регистрации.
- невалидный емейл + валидное имя + валидный пароль = отказ в регистрации.
- валидный емейл + валидное имя + валидный пароль = успешная регистрация.

_**Попарное тестирование.**_ (pairwise testing) - когда каждое значение 
проверяемого параметра единажды тестируется на взаимодействие с каждым 
значением всех остальных параметров. После составления такой 
матрицы мы убираем тесты, которые дублируют друг друга, 
оставляя максимальное покрытие при минимальном необходимом 
наборе сценариев:

    №   Браузер     ОС              Язык
    1   Opera       Windows         RU
    2   Chrome      Linux           RU
    3   Opera       Linux           EN
    4   Chrome      Windows         EN

Source https://www.simbirsoft.com/blog/tekhniki-test-dizayna-i-ikh-prednaznachenie/

### Что такое мутационное тестирование?
Это метод тестирования, который включает небольшие изменения кода программы [мутации]. 
Если набор тестов не в состоянии обнаружить такие изменения, то он рассматривается как недостаточный.

### Метрики автотестов
1. _**Покрытие**_: процент автоматизированных тестов из общего 
   количества тестов.
2. _**Pass rate**_: процент упавших тестов
3. _**Количество информативных падений**_: количество тестов, упавших по причине поимки дефекта,
а не по причине проблем с окружением, смены локатора или проблем с данными.
4. _**Количество пойманных дефектов**_ при помощи автотестов.
5. _**Длительность тестов**_ (особенно UI-тестов)
6. _**Удобство сопровождения**_ (Maintainability) 
7. _**Стабильность**_ тестов - насколько тесты являются устойчивыми. 
   _Примеры_ нестабильных тестов из практики (все перечисленные ошибки 
   так же влияют на удобство сопровождения тестов): 
   `StaleElementReferenceException`
   т.к. нужно больше ожидания для завершения изменений на странице.
   `NoSuchElementException` т.к., например, сущность 
   находится на другой странице (расписание открыто на "текущей" 
   неделе, а смена создана на следующей. Т.к. в коде идет отталкивание 
   от текущего дня и смена создается `tomorrow()`, 
   такой тест будет падать каждое воскресенье, т.к. не сможет
   найти смену, созданную "завтра", т.е. в пн следующей недели), 
   `AssertionError` при проверке захардкоженного сообщения об ошибке, например:
   поменяется формулировка, добавится точка в конце предложения и мы 
   получим бесполезное падение теста при правильной работе приложения. 
   Как выход: использование при проверке сообщений `regexp`-ов или проверка
   строки на `contains()` вместо `equals()`.
   
8. _**Количество дефектов в продакшене**_ - сколько дефектов не 
   было отловлено на этапе тестирования.